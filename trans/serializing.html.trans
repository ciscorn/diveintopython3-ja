en:<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#serializing>Dive Into Python 3</a> <span class=u>&#8227;</span>
ja:<p>現在地: <a href=index.html>ホーム</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#serializing>Dive Into Python 3</a> <span class=u>&#8227;</span>

en:<title>Serializing Python Objects - Dive Into Python 3</title>
ja:<title>Pythonオブジェクトをシリアライズする - Dive Into Python 3 日本語版</title>


en:<h1>Serializing Python Objects</h1>
ja:<h1>Pythonオブジェクトをシリアライズする</h1>


en:<p><span class=u>&#x275D;</span> Every Saturday since we&#8217;ve lived in this apartment, I have awakened at 6:15, poured myself a bowl of cereal, added<br>a quarter-cup of 2% milk, sat on <strong>this</strong> end of <strong>this</strong> couch, turned on BBC America, and watched Doctor Who. <span class=u>&#x275E;</span><br>&mdash; Sheldon, <a href='http://en.wikiquote.org/wiki/The_Big_Bang_Theory#The_Dumpling_Paradox_.5B1.07.5D'>The Big Bang Theory</a>
ja:<p><span class=u>&#x275D;</span>このアパートに来てからの土曜日はいつも、6時15分に起きて、低脂肪牛乳を4分の1カップ入れたシリアルを口に流しこんで、<br><strong>この</strong>カウチの、<strong>この</strong>端っこに座って、BBCアメリカをつけて、ドクター・フーを観てるんだよ。<span class=u>&#x275E;</span><br>&mdash; Sheldon, <a href='http://en.wikiquote.org/wiki/The_Big_Bang_Theory#The_Dumpling_Paradox_.5B1.07.5D'>The Big Bang Theory</a>

en:<h2 id=divingin>Diving In</h2>
ja:<h2 id=divingin>飛び込む</h2>


en:<p class=f>On the surface, the concept of <dfn>serialization</dfn> is simple. You have a data structure in memory that you want to save, reuse, or send to someone else. How would you do that? Well, that depends on how you want to save it, how you want to reuse it, and to whom you want to send it. Many games allow you to save your progress when you quit the game and pick up where you left off when you relaunch the game. (Actually, many non-gaming applications do this as well.) In this case, a data structure that captures &#8220;your progress so far&#8221; needs to be stored on disk when you quit, then loaded from disk when you relaunch. The data is only meant to be used by the same program that created it, never sent over a network, and never read by anything other than the program that created it. Therefore, the interoperability issues are limited to ensuring that later versions of the program can read data written by earlier versions.
ja:<p class=f><dfn>シリアライズ</dfn>の概念は、表面上はシンプルだ。保存したり、再利用したり、他の人に送信したいデータをメモリ上に持っているとしよう。あなたならそれをどのように行うだろうか？ もちろんこれは、そのデータをどのように保存したいのか、どのように再利用したいのか、だれに送りたいのかによって違うだろう。多くのゲームは終了時に「セーブ」を行い、ゲームを再び起動したときに以前の場所から再開できるようになっている（実際には、ゲーム以外の多くのアプリケーションも似たようなことを行っている）。この場合、ゲームの終了時にどこまで進んだかを記録するデータ構造がディスクに保存され、再び起動するときにディスクから読み込まれる必要がある。このデータは、作成したのと同じアプリケーションによって読み込まれるだけで、ネットワーク越しに転送されたり、作成したアプリケーション以外によって読み込まれることは無いという想定で作られている。したがって、相互運用性に関して考慮すべきことは、古いバージョンのプログラムが作成したデータを、新しいバージョンのプログラムが読み込めることを保証することに限られる。


en:<p>For cases like this, the <code>pickle</code> module is ideal. It&#8217;s part of the Python standard library, so it&#8217;s always available. It&#8217;s fast; the bulk of it is written in C, like the Python interpreter itself. It can store arbitrarily complex Python data structures.
ja:<p>このような場合には<code>pickle</code>モジュールがうってつけだ。これはPython標準ライブラリに含まれているのでいつでも利用できるし、Pythonインタプリタと同様に大部分がC言語で書かれているので処理も速い。そして、どんなに複雑なPythonのデータ構造でも保存することができる。


en:<p>What can the <code>pickle</code> module store?
ja:<p><code>pickle</code>モジュールは何を保存できるのか？


en:<li>All the <a href=native-datatypes.html>native datatypes</a> that Python supports: booleans, integers, floating point numbers, complex numbers, strings, <code>bytes</code> objects, byte arrays, and <code>None</code>.
ja:<li>Pythonがサポートするすべての<a href=native-datatypes.html>ネイティブデータ型</a>: ブール値・整数・浮動小数点数・複素数・文字列・<code>bytes</code>オブジェクト・バイト配列・<code>None</code>。


en:<li>Lists, tuples, dictionaries, and sets containing any combination of native datatypes.
ja:<li>ネイティブデータ型の任意の組み合わせからなるリスト・タプル・辞書・集合。


en:<li>Lists, tuples, dictionaries, and sets containing any combination of lists, tuples, dictionaries, and sets containing any combination of native datatypes (and so on, to <a title='sys.getrecursionlimit()' href=http://docs.python.org/3.1/library/sys.html#sys.getrecursionlimit>the maximum nesting level that Python supports</a>).
ja:<li>ネイティブデータ型の任意の組み合わせからなるリスト・タプル・辞書・集合の自由な組み合わせからなるリスト・タプル・辞書・集合（<a title='sys.getrecursionlimit()' href=http://docs.python.org/3.1/library/sys.html#sys.getrecursionlimit>Pythonがサポートする最大のネストレベル</a>までネストできる）


en:<li>Functions, classes, and instances of classes (with caveats).
ja:<li>関数・クラス・クラスのインスタンス（注意あり）。


en:<p>If this isn&#8217;t enough for you, the <code>pickle</code> module is also extensible. If you&#8217;re interested in extensibility, check out the links in the <a href=#furtherreading>Further Reading</a> section at the end of the chapter.
ja:<p>これでも不十分な場合は、<code>pickle</code>モジュールを拡張することもできる。この拡張性に興味がある人は、この章の最後にある<a href=#furtherreading>もっと知りたい人のために</a>のリンクを確認してほしい。


en:<h3 id=administrivia>A Quick Note About The Examples in This Chapter</h3>
ja:<h3 id=administrivia>この章の例についての手短な注意</h3>


en:<p>This chapter tells a tale with two Python Shells. All of the examples in this chapter are part of a single story arc. You will be asked to switch back and forth between the two Python Shells as I demonstrate the <code>pickle</code> and <code>json</code> modules.
ja:<p>この章では、2つのPythonシェルを使って話をする。この章では、すべての例示によって1つの話が構成されている。私が<code>pickle</code>と<code>json</code>モジュールの実演を行うあいだ、皆さんには2つのPythonシェルを行ったり来たりしてもらうことになる。


en:<p>To help keep things straight, open the Python Shell and define the following variable:
ja:<p>混乱を防ぐために、Pythonシェルを開いて次の変数を定義しよう。


en:<p>Keep that window open. Now open another Python Shell and define the following variable:
ja:<p>このウインドウは開いたままにしておこう。今度は、もう一つの新しいPythonシェルを開いて次の変数を定義しよう。


en:<p>Throughout this chapter, I will use the <code>shell</code> variable to indicate which Python Shell is being used in each example.
ja:<p>この章では、各々の例でどちらのPythonシェルが使われているのかを<code>shell</code>変数を使って示すことにする。


en:<h2 id=dump>Saving Data to a Pickle File</h2>
ja:<h2 id=dump>データをPickleファイルに保存する</h2>


en:<p>The <code>pickle</code> module works with data structures. Let&#8217;s build one.
ja:<p><code>pickle</code>モジュールはデータ構造を扱う。まずは1つ作ってみよう。


en:<li>Follow along in Python Shell #1.
ja:<li>Pythonシェル #1 で追っていこう。


en:<li>The idea here is to build a Python dictionary that could represent something useful, like an <a href=xml.html#xml-structure>entry in an Atom feed</a>. But I also want to ensure that it contains several different types of data, to show off the <code>pickle</code> module. Don&#8217;t read too much into these values.
ja:<li>ここでやりたいことは、<a href=xml.html#xml-structure>Atomフィードのエントリ</a>のような何か意味のあるデータを収めたPythonの辞書を作ることだ。しかし、<code>pickle</code>モジュールの能力を見せびらかすために、この辞書が様々なデータ型を格納していることも強調しておきたい。これらの値の内容については気にしなくて良い。


en:<li>The <code>time</code> module contains a data structure (<code>time_struct</code>) to represent a point in time (accurate to one millisecond) and functions to manipulate time structs. The <code>strptime()</code> function takes a formatted string an converts it to a <code>time_struct</code>. This string is in the default format, but you can control that with format codes. See the <a href=http://docs.python.org/3.1/library/time.html><code>time</code> module</a> for more details.
ja:<li><code>time</code>モジュールは、時刻上の1点（ミリ秒までの精度を持つ）を表現するためのデータ構造 (<code>time_struct</code>) と、そのデータ構造を操作するための関数を含んでいる。<code>strptime()</code>関数は、フォーマットされた文字列を受け取って<code>time_struct</code>に変換する。この文字列はデフォルトの形式で表現されているが、フォーマットコードによって制御することもできる。詳しくは<a href=http://docs.python.org/3.1/library/time.html><code>time</code>モジュール</a>を見てほしい。


en:<p>That&#8217;s a handsome-looking Python dictionary. Let&#8217;s save it to a file.
ja:<p>カッコイイPythonの辞書ができた。これをファイルに保存しよう。


en:<li>This is still in Python Shell #1.
ja:<li>まだPythonシェル #1 にいる。


en:<li>Use the <code>open()</code> function to open a file. Set the file mode to <code>'wb'</code> to open the file for writing <a href=files.html#binary>in binary mode</a>. Wrap it in a <a href=files.html#with><code>with</code> statement</a> to ensure the file is closed automatically when you&#8217;re done with it.
ja:<li><code>open()</code>関数を使ってファイルを開く。ファイルを<a href=files.html#binary>バイナリモード</a>で開くために、ファイルモードは<code>'wb'</code>に設定しよう。これを<a href=files.html#with><code>with</code>文</a>で包むことで、保存が終わったときに自動的にファイルが閉じられるようにしておく。


en:<li>The <code>dump()</code> function in the <code>pickle</code> module takes a serializable Python data structure, serializes it into a binary, Python-specific format using the latest version of the pickle protocol, and saves it to an open file.
ja:<li><code>pickle</code>モジュールの<code>dump()</code>関数は、シリアライズ可能なPythonのデータ構造を1つ受け取り、それを最新のバージョンのPickleプロトコルを用いてPython固有のバイナリ形式にシリアライズした上で、開いておいたファイルにそれを保存する。


en:<p>That last sentence was pretty important.
ja:<p>最後の文はとても重要だ。


en:<li>The <code>pickle</code> module takes a Python data structure and saves it to a file.
ja:<li><code>pickle</code>モジュールはPythonのデータ構造を受け取り、それをファイルに保存する。


en:<li>To do this, it <i>serializes</i> the data structure using a data format called &#8220;the pickle protocol.&#8221;
ja:<li>これを行うために、このモジュールは「Pickleプロトコル」と呼ばれる形式を用いてデータ構造を「シリアライズ」する。


en:<li>The pickle protocol is Python-specific; there is no guarantee of cross-language compatibility. You probably couldn&#8217;t take the <code>entry.pickle</code> file you just created and do anything useful with it in Perl, <abbr>PHP</abbr>, Java, or any other language.
ja:<li>PickleプロトコルはPython固有のものであり、他の言語で使用できる保証は無い。Perl、<abbr>PHP</abbr>、Java、その他のいかなる言語であっても、<code>entry.pickle</code>ファイルを有効に使うことはできないだろう。


en:<li>Not every Python data structure can be serialized by the <code>pickle</code> module. The pickle protocol has changed several times as new data types have been added to the Python language, but there are still limitations.
ja:<li><code>pickle</code>モジュールは、Pythonのあらゆるデータ構造をシリアライズできるわけではない。Pythonに新しい型が追加されるたびにPickleプロトコルには何度も変更が加えられてきているが、制限は依然として存在する。


en:<li>As a result of these changes, there is no guarantee of compatibility between different versions of Python itself. Newer versions of Python support the older serialization formats, but older versions of Python do not support newer formats (since they don&#8217;t support the newer data types).
ja:<li>これらの変更の結果として、Python自体の異なるバージョン間においても互換性の保証がない。新しいバージョンのPythonは、古いバージョンのシリアライズ形式をサポートするが、古いバージョンのPythonは（新しい型をサポートしていないので）新しいシリアライズ形式をサポートしない。


en:<li>Unless you specify otherwise, the functions in the <code>pickle</code> module will use the latest version of the pickle protocol. This ensures that you have maximum flexibility in the types of data you can serialize, but it also means that the resulting file will not be readable by older versions of Python that do not support the latest version of the pickle protocol.
ja:<li>特に指定しない限り、<code>pickle</code>モジュールの関数は、最新バージョンのPickleプロトコルを使用する。このおかげでシリアライズできるデータ型の範囲は最も広くなるのだが、その代償として、最新のPickleプロトコルをサポートしていない古いバージョンのPythonでは生成されるPickleファイルを読み込めなくなってしまう。


en:<li>The latest version of the pickle protocol is a binary format. Be sure to open your pickle files <a href=files.html#binary>in binary mode</a>, or the data will get corrupted during writing.
ja:<li>最新バージョンのPickleプロトコルはバイナリ形式だ。Pickleファイルが<a href=files.html#binary>バイナリモード</a>で開かれていることを確認しよう。さもなければ、データは書き込み中に破損してしまうだろう。


en:<h2 id=load>Loading Data from a Pickle File</h2>
ja:<h2 id=load>データをPickleファイルから読み込む</h2>


en:<p>Now switch to your second Python Shell&nbsp;&mdash;&nbsp;<i>i.e.</i> not the one where you created the <code>entry</code> dictionary.
ja:<p>今度は2つ目のPythonシェル&nbsp;&mdash;&nbsp;つまり<code>entry</code>辞書を作ったシェルではない方のシェルに切り替えよう。


en:<li>This is Python Shell #2.
ja:<li>これはPythonシェル #2 だ。


en:<li>There is no <var>entry</var> variable defined here. You defined an <var>entry</var> variable in Python Shell #1, but that&#8217;s a completely different environment with its own state.
ja:<li>ここでは<var>entry</var>変数が定義されていない。Pythonシェル #1 において<var>entry</var>変数を定義したが、それは独自の状態を持つ完全に異なる環境だ。


en:<li>Open the <code>entry.pickle</code> file you created in Python Shell #1. The <code>pickle</code> module uses a binary data format, so you should always open pickle files in binary mode.
ja:<li>Pythonシェル #1 で作った<code>entry.pickle</code>ファイルを開こう。<code>pickle</code>モジュールはバイナリ形式を使うので、Pickleファイルは常にバイナリモードで開かなければならない。


en:<li>The <code>pickle.load()</code> function takes a <a href=files.html#file-objects>stream object</a>, reads the serialized data from the stream, creates a new Python object, recreates the serialized data in the new Python object, and returns the new Python object.
ja:<li><code>pickle.load()</code>関数は、<a href=files.html#file-objects>ストリームオブジェクト</a>を受け取り、ストリームからシリアライズされたデータを読み込み、新しいPythonオブジェクトを作り、シリアライズされたデータを新しいPythonオブジェクトの中に再構成し、その新しいPythonオブジェクトを返す。


en:<li>Now the <var>entry</var> variable is a dictionary with familiar-looking keys and values.
ja:<li>さて、<var>entry</var>変数は、見覚えのあるキーと値を持つ辞書になった。


en:<p>The <code>pickle.dump() / pickle.load()</code> cycle results in a new data structure that is equal to the original data structure.
ja:<p><code>pickle.dump() / pickle.load()</code>のサイクルによって、元のデータ構造と等しい内容をもつ新たなデータ構造がもたらされる。


en:<li>Switch back to Python Shell #1.
ja:<li>Pythonシェル #1 へ戻ろう。


en:<li>Open the <code>entry.pickle</code> file.
ja:<li><code>entry.pickle</code>ファイルを開こう。


en:<li>Load the serialized data into a new variable, <var>entry2</var>.
ja:<li>シリアライズされたデータを新しい変数<var>entry2</var>に読み込もう。


en:<li>Python confirms that the two dictionaries, <var>entry</var> and <var>entry2</var>, are equal. In this shell, you built <var>entry</var> from the ground up, starting with an empty dictionary and manually assigning values to specific keys. You serialized this dictionary and stored it in the <code>entry.pickle</code> file. Now you&#8217;ve read the serialized data from that file and created a perfect replica of the original data structure.
ja:<li>2つの辞書<var>entry</var>と<var>entry2</var>が等しいことをPythonが認めている。このシェルでは、空の辞書からスタートし、特定のキーに手作業で値を設定することで<var>entry</var>を組み上げた。そして、この辞書をシリアライズし、<code>entry.pickle</code>ファイルに保存した。さらに、そのファイルからシリアライズされたデータを読み込んで、元のデータ構造の完全な複製を作成した。


en:<li>Equality is not the same as identity. I said you&#8217;ve created a <em>perfect replica</em> of the original data structure, which is true. But it&#8217;s still a copy.
ja:<li>等しいことと同一であることは違う。私は、元のデータ構造の<em>完全な複製</em>を作ったと言った。これは正しい。しかし、これはコピーに過ぎないのだ。


en:<li>For reasons that will become clear later in this chapter, I want to point out that the value of the <code>'tags'</code> key is a tuple, and the value of the <code>'internal_id'</code> key is a <code>bytes</code> object.
ja:<li>ここで、<code>'tags'</code>キーの値がタプルであることと、<code>'internal_id'</code>キーの値が<code>bytes</code>オブジェクトであることを指摘しておきたい。指摘した理由は後で分かる。


en:<h2 id=dumps>Pickling Without a File</h2>
ja:<h2 id=dumps>ファイルを使わずにPickle化する</h2>


en:<p>The examples in the previous section showed how to serialize a Python object directly to a file on disk. But what if you don&#8217;t want or need a file? You can also serialize to a <code>bytes</code> object in memory.
ja:<p>前節の例は、Pythonオブジェクトをディスク上のファイルに直接シリアライズする方法を示していた。しかし、ファイルが必要ない場合や、ファイルを使わずにやりたい場合はどうすればいいのだろうか？ <code>pickle</code>は、メモリ上の<code>bytes</code>オブジェクトにシリアライズすることもできるのだ。


en:<li>The <code>pickle.dumps()</code> function (note the <code>'s'</code> at the end of the function name) performs the same serialization as the <code>pickle.dump()</code> function. Instead of taking a stream object and writing the serialized data to a file on disk, it simply returns the serialized data.
ja:<li><code>pickle.dumps()</code>関数（関数名の末尾に<code>'s'</code>が付いていることに注意）は、<code>pickle.dump()</code>関数と同様のシリアライズを行う。ただし、ストリームオブジェクトを受け取って、ディスク上のファイルにシリアライズしたデータを書き込む代わりに、ただ単にシリアライズしたデータを返すだけだ。


en:<li>Since the pickle protocol uses a binary data format, the <code>pickle.dumps()</code> function returns a <code>bytes</code> object.
ja:<li>Pickleプロトコルはバイナリ形式を用いるので、<code>pickle.dumps()</code>関数は<code>bytes</code>オブジェクトを返す。


en:<li>The <code>pickle.loads()</code> function (again, note the <code>'s'</code> at the end of the function name) performs the same deserialization as the <code>pickle.load()</code> function. Instead of taking a stream object and reading the serialized data from a file, it takes a <code>bytes</code> object containing serialized data, such as the one returned by the <code>pickle.dumps()</code> function.
ja:<li><code>pickle.loads()</code>関数（再び、関数名の末尾に<code>'s'</code>が付いていることに注意）は、<code>pickle.load()</code>関数と同様のデシリアライズを行う。ただし、ストリームオブジェクトを受け取って、ファイルからシリアライズされたデータを読み込む代わりに、<code>pickle.dumps()</code>関数が生成するような、シリアライズされたデータを含んだ<code>bytes</code>オブジェクトを受け取る。


en:<li>The end result is the same: a perfect replica of the original dictionary.
ja:<li>結果は同じだ。つまり、元の辞書の完全な複製だ。


en:<h2 id=protocol-versions>Bytes and Strings Rear Their Ugly Heads Again</h2>
ja:<h2 id=protocol-versions>バイト列と文字列が再び不快な姿を現す</h2>


en:<p>The pickle protocol has been around for many years, and it has matured as Python itself has matured. There are now <a href=http://docs.python.org/3.1/library/pickle.html#data-stream-format>four different versions</a> of the pickle protocol.
ja:<p>Pickleプロトコルが最初に考案されたのは何年も前のことであり、Pythonが言語として成熟するのにあわせて、このプロトコルも成長してきた。現在は<a href=http://docs.python.org/3.1/library/pickle.html#data-stream-format>4つの異なるバージョン</a>のPickleプロトコルが存在する。


en:<li>Python 1.x had two pickle protocols, a text-based format (&#8220;version 0&#8221;) and a binary format (&#8220;version 1&#8221;).
ja:<li>Python 1.xは、２つのPickleプロトコルを持っていた。テキスト形式（バージョン0）とバイナリ形式（バージョン 1）だ。


en:<li>Python 2.3 introduced a new pickle protocol (&#8220;version 2&#8221;) to handle new functionality in Python class objects. It is a binary format.
ja:<li>Python 2.3では、Pythonのクラスオブジェクトの新機能を扱うために、新しいPickleプロトコル（バージョン2）が導入された。これはバイナリ形式だ。


en:<li>Python 3.0 introduced another pickle protocol (&#8220;version 3&#8221;) with explicit support for <code>bytes</code> objects and byte arrays. It is a binary format.
ja:<li>Python 3.0では、<code>bytes</code>オブジェクトとバイト配列の明示的なサポートをもつ、もう一つのPickleプロトコルが導入された（バージョン3）。これはバイナリ形式だ。


en:<p>Oh look, <a href=strings.html#byte-arrays>the difference between bytes and strings</a> rears its ugly head again. (If you&#8217;re surprised, you haven&#8217;t been paying attention.) What this means in practice is that, while Python 3 can read data pickled with protocol version 2, Python 2 can not read data pickled with protocol version 3.
ja:<p>ああ、見てほしい。<a href=strings.html#byte-arrays>バイト列と文字列の違い</a>が再び不快な姿を表した（ここで驚いたのなら、注意を払っていなかったのだろう）。これが実際問題として示す意味はこうだ。つまり、Python 3はプロトコルバージョン2でPickle化されたデータを読み込むことができるが、Python 2はプロトコルバージョン3でPickle化されたデータを読み込むことができないのだ。


en:<h2 id=debugging>Debugging Pickle Files</h2>
ja:<h2 id=debugging>Pickleファイルをデバッグする</h2>


en:<p>What does the pickle protocol look like? Let&#8217;s jump out of the Python Shell for a moment and take a look at that <code>entry.pickle</code> file we created.
ja:<p>Pickleプロトコルはどのような姿をしているのだろうか？ Pythonシェルから少しのあいだ飛び出して、さきほど作った<code>entry.pickle</code>を見てみよう。


en:<p>That wasn&#8217;t terribly helpful. You can see the strings, but other datatypes end up as unprintable (or at least unreadable) characters. Fields are not obviously delimited by tabs or spaces. This is not a format you would want to debug by yourself.
ja:<p>これでは何の参考にもならない。文字列は判読できるものの、他のデータ型は非印字文字（もしくは、少なくとも読めない文字）になってしまっているし、フィールドがタブやスペースで区切られているわけでもないようだ。この形式を自分でデバッグしようとは思わないだろう。


en:<p>The most interesting piece of information in that disassembly is on the last line, because it includes the version of the pickle protocol with which this file was saved. There is no explicit version marker in the pickle protocol. To determine which protocol version was used to store a pickle file, you need to look at the markers (&#8220;opcodes&#8221;) within the pickled data and use hard-coded knowledge of which opcodes were introduced with each version of the pickle protocol. The <code>pickle.dis()</code> function does exactly that, and it prints the result in the last line of the disassembly output. Here is a function that returns just the version number, without printing anything:
ja:<p>これはファイルを逆アセンブルしたものだが、最も興味深い情報は最後の行に含まれている。というのも、この行にはファイルを保存したときに使ったPickleプロトコルのバージョンが記されているからだ。Pickleプロトコルには、バージョンを示すための明示的なマーカが存在しない。したがって、ファイルの保存にどのバージョンのプロトコルが用いられたのかを知るためには、Pickle化されたデータの中にある目印（&#8220;opcodes&#8221;）に目を向けて、「どのopcodeがどのバージョンのPickleプロトコルで導入されたのか」というハードコードされた知識をもとに推測を行うしかない。<code>pickletools.dis()</code>関数もこの方法でバージョンを識別しており、その結果を逆アセンブリ出力の最後の行に表示してくれる。次に示すのは、何も表示することなく、単にバージョン番号のみを返す関数だ。


en:<p class=d>[<a href=examples/pickleversion.py>download <code>pickleversion.py</code></a>]
ja:<p class=d>[<a href=examples/pickleversion.py><code>pickleversion.py</code>をダウンロードする</a>]


en:<p>And here it is in action:</p>
ja:<p>これは次のように使う:</p>


en:<h2 id=json>Serializing Python Objects to be Read by Other Languages</h2>
ja:<h2 id=json>Pythonオブジェクトを他の言語で読むためにシリアライズする</h2>


en:<p>The data format used by the <code>pickle</code> module is Python-specific. It makes no attempt to be compatible with other programming languages. If cross-language compatibility is one of your requirements, you need to look at other serialization formats. One such format is <a href=http://json.org/><abbr>JSON</abbr></a>. &#8220;<abbr>JSON</abbr>&#8221; stands for &#8220;JavaScript Object Notation,&#8221; but don&#8217;t let the name fool you&nbsp;&mdash;&nbsp;<abbr>JSON</abbr> is explicitly designed to be usable across multiple programming languages.
ja:<p><code>pickle</code>モジュールが使っているデータ形式はPython固有のものであり、他のプログラミング言語との互換性をとる努力は行われていない。言語間の互換性が必要な場合は、他のシリアライズ形式に目を向ける必要がある。そのような形式の1つとして<a href=http://json.org/><abbr>JSON</abbr></a>がある。&#8220;<abbr>JSON</abbr>&#8221; は &#8220;JavaScript Object Notation&#8221; の略だが、この名前に騙されてはいけない。<abbr>JSON</abbr>は、様々な言語間で使えるように明確に設計されているのだ。


en:<p>Python 3 includes a <code>json</code> module in the standard library. Like the <code>pickle</code> module, the <code>json</code> module has functions for serializing data structures, storing the serialized data on disk, loading serialized data from disk, and unserializing the data back into a new Python object. But there are some important differences, too. First of all, the <abbr>JSON</abbr> data format is text-based, not binary. <a href=http://www.ietf.org/rfc/rfc4627.txt>RFC 4627</a> defines the <abbr>JSON</abbr> format and how different types of data must be encoded as text. For example, a boolean value is stored as either the five-character string <code>'false'</code> or the four-character string <code>'true'</code>. All <abbr>JSON</abbr> values are case-sensitive.
ja:<p>Python 3の標準ライブラリの中には<code>json</code>モジュールが含まれている。<code>json</code>モジュールは、<code>pickle</code>モジュールと同様に、データ構造をシリアライズする関数、シリアライズされたデータをディスクに保存する関数、シリアライズされたデータをディスクから読み込む関数、データをデシリアライズして新しいPythonオブジェクトに戻す関数を持っている。しかし、重要な違いもいくつか存在する。まず第一に、<abbr>JSON</abbr>のデータ形式はバイナリ形式ではなくテキスト形式だ。<a href=http://www.ietf.org/rfc/rfc4627.txt>RFC 4627</a>は、<abbr>JSON</abbr>の形式と、個々の異なる型がどのようにテキストとしてエンコードされるのかを定義している。例えばブール値は、5文字の文字列<code>'false'</code>、もしくは4文字の文字列<code>'true'</code>として保存される。<abbr>JSON</abbr>のすべての値は、大文字と小文字が区別される。


en:<p>Second, as with any text-based format, there is the issue of whitespace. <abbr>JSON</abbr> allows arbitrary amounts of whitespace (spaces, tabs, carriage returns, and line feeds) between values. This whitespace is &#8220;insignificant,&#8221; which means that <abbr>JSON</abbr> encoders can add as much or as little whitespace as they like, and <abbr>JSON</abbr> decoders are required to ignore the whitespace between values. This allows you to &#8220;pretty-print&#8221; your <abbr>JSON</abbr> data, nicely nesting values within values at different indentation levels so you can read it in a standard browser or text editor. Python&#8217;s <code>json</code> module has options for pretty-printing during encoding.
ja:<p>第二に、テキストベースの形式ではいつも問題となることだが、ホワイトスペースの扱いがある。<abbr>JSON</abbr>では、値のあいだに任意個のホワイトスペース（空白・タブ・キャリッジリターン・ラインフィード) を置くことが許されている。このホワイトスペースは「意味を持たない」とされている。すなわち、<abbr>JSON</abbr>のエンコーダは好きなようにホワイトスペースを加えることができるし、<abbr>JSON</abbr>のデコーダはホワイトスペースを無視するよう仕様で定められているのだ。これによって、<abbr>JSON</abbr>のデータを &#8220;pretty-print&#8221;、つまり、異なるレベルのインデントを加えて、値を値の中にきれいにネストさせて出力できるので、標準的なブラウザやテキストエディタで容易にこのデータを読むことができる。Pythonの<code>json</code>モジュールは、エンコード時に &#8220;pretty-print&#8221; を行うオプションを持っている。


en:<p>Third, there&#8217;s the perennial problem of character encoding. <abbr>JSON</abbr> encodes values as plain text, but as you know, <a href=strings.html>there ain&#8217;t no such thing as &#8220;plain text.&#8221;</a> <abbr>JSON</abbr> must be stored in a Unicode encoding (UTF-32, UTF-16, or the default, <abbr>UTF-8</abbr>), and <a href=http://www.ietf.org/rfc/rfc4627.txt>section 3 of RFC 4627</a> defines how to tell which encoding is being used.
ja:<p>第三に、これまで何度も見てきた文字コードの問題がある。<abbr>JSON</abbr>はプレーンテキストとして値を保存するが、知っての通り<a href=strings.html>「プレーンテキスト」などというものは存在しない</a>。<abbr>JSON</abbr>は、Unicodeエンコーディング（UTF-32・UTF-16・<abbr>UTF-8</abbr>。デフォルトは<abbr>UTF-8</abbr>）で保存されなければならない。<a href=http://www.ietf.org/rfc/rfc4627.txt>RFC 4627の第3節</a>は、どのエンコーディングが使われているのかを見分ける方法を定義している。


en:<h2 id=json-dump>Saving Data to a <abbr>JSON</abbr> File</h2>
ja:<h2 id=json-dump>データを<abbr>JSON</abbr>ファイルに保存する</h2>


en:<p><abbr>JSON</abbr> looks remarkably like a data structure you might define manually in JavaScript. This is no accident; you can actually use the JavaScript <code>eval()</code> function to &#8220;decode&#8221; <abbr>JSON</abbr>-serialized data. (The usual <a href=advanced-iterators.html#eval>caveats about untrusted input</a> apply, but the point is that <abbr>JSON</abbr> <em>is</em> valid JavaScript.) As such, <abbr>JSON</abbr> may already look familiar to you.
ja:<p><abbr>JSON</abbr>は、JavaScriptで手作業で定義するようなデータ構造と非常によく似ている。これは偶然ではなく、実際に、<abbr>JSON</abbr>でシリアライズされたデータをJavaScriptの<code>eval()</code>関数を使って「デコード」することができる（通例の<a href=advanced-iterators.html#eval>信頼されていない入力に関する警告</a>は適用されるが、ここで言いたいのは、<abbr>JSON</abbr>はJavaScriptの値として有効だということだ）。そんなわけで、<abbr>JSON</abbr> はあなたにとって見覚えのあるものかもしれない。


en:<li>We&#8217;re going to create a new data structure instead of re-using the existing <var>entry</var> data structure. Later in this chapter, we&#8217;ll see what happens when we try to encode the more complex data structure in <abbr>JSON</abbr>.
ja:<li>すでに存在するデータ構造<var>entry</var>を使う代わりに、新しいデータ構造を定義しよう。この章では後に、もっと複雑なデータ構造を<abbr>JSON</abbr>でエンコードしようとしたときに何が起きるのかを見ることになる。


en:<li><abbr>JSON</abbr> is a text-based format, which means you need to open this file in text mode and specify a character encoding. You can never go wrong with <abbr>UTF-8</abbr>.
ja:<li><abbr>JSON</abbr>はテキストベースの形式だ。つまり、このファイルはテキスト形式で開かなければならず、文字コードも指定する必要がある。<abbr>UTF-8</abbr>を使っておけば問題は決して起きない。


en:<li>Like the <code>pickle</code> module, the <code>json</code> module defines a <code>dump()</code> function which takes a Python data structure and a writeable stream object. The <code>dump()</code> function serializes the Python data structure and writes it to the stream object. Doing this inside a <code>with</code> statement will ensure that the file is closed properly when we&#8217;re done.
ja:<li><code>pickle</code>モジュールと同様に、<code>json</code>モジュールは、Pythonのデータ構造と書き込み可能なストリームオブジェクトを受け取る<code>dump()</code>関数を定義している。<code>dump()</code>関数はPythonのデータ構造をシリアライズして、それをストリームオブジェクトに書き込む。これを<code>with</code>文の中で行うことによって、処理が終わったときにファイルが適切に閉じられることを保証している。


en:<p>So what does the resulting <abbr>JSON</abbr> serialization look like?
ja:<p>では、<abbr>JSON</abbr>のシリアライズ結果はどうなっているだろうか？


en:<p>That&#8217;s certainly <a href=#debugging>more readable than a pickle file</a>. But <abbr>JSON</abbr> can contain arbitrary whitespace between values, and the <code>json</code> module provides an easy way to take advantage of this to create even more readable <abbr>JSON</abbr> files.
ja:<p>これは明らかに<a href=#debugging>Pickleファイルよりも読みやすい</a>。しかし、<abbr>JSON</abbr>は、値のあいだに任意個のホワイトスペースを入れることができるので、<code>json</code>モジュールはこの長所を生かして、さらに読みやすい<abbr>JSON</abbr>ファイルを手軽に作る方法を提供している。


en:<li>If you pass an <var>indent</var> parameter to the <code>json.dump()</code> function, it will make the resulting <abbr>JSON</abbr> file more readable, at the expense of larger file size. The <var>indent</var> parameter is an integer. 0 means &#8220;put each value on its own line.&#8221; A number greater than 0 means &#8220;put each value on its own line, and use this number of spaces to indent nested data structures.&#8221;
ja:<li><var>indent</var>パラメータを<code>json.dump()</code>関数に渡すと、<abbr>JSON</abbr>ファイルをより読みやすい形に整形して出力してくれる（その代わりに、ファイルサイズは増えるが）。<var>indent</var>パラメータは整数だ。これを0にすると「各々の値ごとに1行を使う」という意味になる。0より大きい数を与えた場合は、「各々の値ごとに1行を使い、さらに指定した数の空白を使ってデータ構造をインデントする」という意味になる。


en:<p>And this is the result:
ja:<p>そして、これがその結果だ：


en:<h2 id=json-types>Mapping of Python Datatypes to <abbr>JSON</abbr></h2>
ja:<h2 id=json-types>Pythonのデータ型を<abbr>JSON</abbr>にマッピングする</h2>


en:<p>Since <abbr>JSON</abbr> is not Python-specific, there are some mismatches in its coverage of Python datatypes. Some of them are simply naming differences, but there is two important Python datatypes that are completely missing. See if you can spot them:
ja:<p><abbr>JSON</abbr>はPython固有の形式ではないので、Pythonのデータ型とのミスマッチがいくつか存在する。いくつかは単に名前が違うだけであるが、Pythonの重要なデータ型のうちの２つは完全に欠けてしまっている。その２つを以下の表から見つけることができるだろうか：


en:<tr><th>Notes
ja:<tr><th>注

en:<td>object
ja:<td>オブジェクト

en:<td><a href=native-datatypes.html#dictionaries>dictionary</a>
ja:<td><a href=native-datatypes.html#dictionaries>辞書</a>

en:<td>array
ja:<td>配列

en:<td><a href=native-datatypes.html#lists>list</a>
ja:<td><a href=native-datatypes.html#lists>リスト</a>

en:<td>string
ja:<td>文字列

en:<td><a href=strings.html#divingin>string</a>
ja:<td><a href=strings.html#divingin>文字列</a>

en:<td>integer
ja:<td>整数

en:<td><a href=native-datatypes.html#numbers>integer</a>
ja:<td><a href=native-datatypes.html#numbers>整数</a>

en:<td>real number
ja:<td>実数

en:<td><a href=native-datatypes.html#numbers>float</a>
ja:<td><a href=native-datatypes.html#numbers>浮動小数点数</a>

en:<tfoot><tr><td colspan=3>* All <abbr>JSON</abbr> values are case-sensitive.
ja:<tfoot><tr><td colspan=3>* すべての<abbr>JSON</abbr>の値は大文字と小文字が区別される。


en:<p>Did you notice what was missing? Tuples <i class=baa>&amp;</i> bytes! <abbr>JSON</abbr> has an array type, which the <code>json</code> module maps to a Python list, but it does not have a separate type for &#8220;frozen arrays&#8221; (tuples). And while <abbr>JSON</abbr> supports strings quite nicely, it has no support for <code>bytes</code> objects or byte arrays.
ja:<p>何が欠けているか気付いただろうか？ タプルとバイト列だ。<abbr>JSON</abbr>は配列型を持っており、<code>json</code>モジュールはこれをPythonのリストにマッピングする。しかし、<abbr>JSON</abbr>は「凍結された配列」（タプル）を持たない。また、<abbr>JSON</abbr>は、文字列を非常に上手くサポートする一方で、<code>bytes</code>オブジェクトやバイト配列はサポートしない。


en:<h2 id=json-unknown-types>Serializing Datatypes Unsupported by <abbr>JSON</abbr></h2>
ja:<h2 id=json-unknown-types><abbr>JSON</abbr>がサポートしていないデータ型をシリアライズする</h2>


en:<p>Even if <abbr>JSON</abbr> has no built-in support for bytes, that doesn&#8217;t mean you can&#8217;t serialize <code>bytes</code> objects. The <code>json</code> module provides extensibility hooks for encoding and decoding unknown datatypes. (By &#8220;unknown,&#8221; I mean &#8220;not defined in <abbr>JSON</abbr>.&#8221; Obviously the <code>json</code> module knows about byte arrays, but it&#8217;s constrained by the limitations of the <abbr>JSON</abbr> specification.) If you want to encode bytes or other datatypes that <abbr>JSON</abbr> doesn&#8217;t support natively, you need to provide custom encoders and decoders for those types.
ja:<p><abbr>JSON</abbr>が組み込みでバイト列をサポートしていないと言えども、<code>bytes</code>オブジェクトのシリアライズが不可能なわけではない。<code>json</code>モジュールは、未知のデータ型をエンコード/デコードするためのフックを仕掛けることができるようになっている（「未知の」という言葉は「<abbr>JSON</abbr>で定義されていない」という意味だ。<code>json</code>モジュールはもちろんバイト列の存在を認識しているが、このモジュールは<abbr>JSON</abbr>の仕様によって制約されているのだ）。バイト列や<abbr>JSON</abbr>がネイティブでサポートしない他のデータ型をエンコードしたい場合には、それらの型のための自作のエンコーダとデコーダを用意する必要がある。


en:<li>OK, it&#8217;s time to revisit the <var>entry</var> data structure. This has it all: a boolean value, a <code>None</code> value, a string, a tuple of strings, a <code>bytes</code> object, and a <code>time</code> structure.
ja:<li>よし、<var>entry</var>データ構造を再び使う時が来たようだ。これにはあらゆるものが含まれる： ブール値、<code>None</code>、文字列、文字列のタプル、<code>bytes</code>オブジェクト、そして<code>time</code>データ構造だ。


en:<li>I know I&#8217;ve said it before, but it&#8217;s worth repeating: <abbr>JSON</abbr> is a text-based format. Always open <abbr>JSON</abbr> files in text mode with a <abbr>UTF-8</abbr> character encoding.
ja:<li>前にも言ったことだが、これは繰り返し言っておく価値がある: <abbr>JSON</abbr>はテキスト形式だ。<abbr>JSON</abbr>ファイルは、文字コードを<abbr>UTF-8</abbr>にしてテキストモードで開こう。


en:<li>Well <em>that&#8217;s</em> not good. What happened?
ja:<li>これはマズい。何が起きたのだろうか？


en:<p>Here&#8217;s what happened: the <code>json.dump()</code> function tried to serialize the <code>bytes</code> object <code>b'\xDE\xD5\xB4\xF8'</code>, but it failed, because <abbr>JSON</abbr> has no support for <code>bytes</code> objects. However, if storing bytes is important to you, you can define your own &#8220;mini-serialization format.&#8221;
ja:<p>ここで起きたのは次のようなことだ: <code>json.dump()</code>関数が<code>bytes</code>オブジェクト<code>b'\xDE\xD5\xB4\xF8'</code>をシリアライズしようとしたが、<abbr>JSON</abbr>は<code>bytes</code>オブジェクトをサポートしていないので失敗した。しかし、どうしてもバイト列を保存したい場合には、独自の「小さなシリアライズ形式」を定義することができる。


en:<p class=d>[<a href=examples/customserializer.py>download <code>customserializer.py</code></a>]
ja:<p class=d>[<a href=examples/customserializer.py><code>customserializer.py</code>をダウンロードする</a>]


en:<li>To define your own &#8220;mini-serialization format&#8221; for a datatype that <abbr>JSON</abbr> doesn&#8217;t support natively, just define a function that takes a Python object as a parameter. This Python object will be the actual object that the <code>json.dump()</code> function is unable to serialize by itself&nbsp;&mdash;&nbsp;in this case, the <code>bytes</code> object <code>b'\xDE\xD5\xB4\xF8'</code>.
ja:<li><abbr>JSON</abbr>がネイティブにサポートしないデータ型のための独自の「小さなシリアライズ形式」を定義するには、パラメータとして1つのPythonオブジェクトを受け取る関数を定義すればいい。<code>json.dump()</code>関数が自分自身ではシリアライズできない実際のオブジェクトが、このPythonオブジェクトとして渡されることになる。この例では、それは<code>bytes</code>オブジェクトの<code>b'\xDE\xD5\xB4\xF8'</code>だ。


en:<li>Your custom serialization function should check the type of the Python object that the <code>json.dump()</code> function passed to it. This is not strictly necessary if your function only serializes one datatype, but it makes it crystal clear what case your function is covering, and it makes it easier to extend if you need to add serializations for more datatypes later.
ja:<li>自作のシリアライズ関数は、<code>json.dump()</code>関数が渡してきたPythonオブジェクトの型をチェックすべきだ。厳密には、その関数が1つのデータ型だけをシリアライズするのであれば必要ないのだが、このチェックは関数がどの型を対象にしているのかを非常に明白にしてくれるし、あとになって他のデータ型をシリアライズする必要に迫られたときの拡張も容易になる。


en:<li>In this case, I&#8217;ve chosen to convert a <code>bytes</code> object into a dictionary. The <code>__class__</code> key will hold the original datatype (as a string, <code>'bytes'</code>), and the <code>__value__</code> key will hold the actual value. Of course this can&#8217;t be a <code>bytes</code> object; the entire point is to convert it into something that can be serialized in <abbr>JSON</abbr>! A <code>bytes</code> object is just a sequence of integers; each integer is somewhere in the range 0&ndash;255. We can use the <code>list()</code> function to convert the <code>bytes</code> object into a list of integers. So <code>b'\xDE\xD5\xB4\xF8'</code> becomes <code>[222, 213, 180, 248]</code>. (Do the math! It works! The byte <code>\xDE</code> in hexadecimal is 222 in decimal, <code>\xD5</code> is 213, and so on.)
ja:<li>今回は<code>bytes</code>オブジェクトを辞書に変換することにした。<code>__class__</code>キーが元のデータ型を（文字列<code>'bytes</code>として）格納し、<code>__value__</code>キーが実際の値を格納する。もちろん、この値として<code>bytes</code>オブジェクトを使うことはできないので、これを<abbr>JSON</abbr>でシリアライズできる何らかの値に変換することが必要だ。<code>bytes</code>は整数のシーケンスなので、各々の整数は0&ndash;255の範囲のいずれかになる。私たちは、<code>list()</code>関数を使って<code>bytes</code>オブジェクトを整数のリストに変換することができる。つまり、<code>b'\xDE\xD5\xB4\xF8'</code>は<code>[222, 213, 180, 248]</code>になる（計算すれば分かる！ ちゃんと動いているよ！ 16進数で<code>\xDE</code>のバイトは10進数では222。<code>\xD5</code>は213。以下同様）。


en:<li>This line is important. The data structure you&#8217;re serializing may contain types that neither the built-in <abbr>JSON</abbr> serializer nor your custom serializer can handle. In this case, your custom serializer must raise a <code>TypeError</code> so that the <code>json.dump()</code> function knows that your custom serializer did not recognize the type.
ja:<li>この行は重要だ。シリアライズしようとしているデータは、組み込みの<abbr>JSON</abbr>シリアライザでも、自作のシリアライザでも扱えない型を含んでいるかもしれない。その場合は、自作のシリアライザが<code>TypeError</code>を発生させることによって、自作のシリアライザがその型を認識できないことを<code>json.dump()</code>関数に知らせなければならない。


en:<p>That&#8217;s it; you don&#8217;t need to do anything else. In particular, this custom serialization function <em>returns a Python dictionary</em>, not a string. You&#8217;re not doing the entire serializing-to-<abbr>JSON</abbr> yourself; you&#8217;re only doing the converting-to-a-supported-datatype part. The <code>json.dump()</code> function will do the rest.
ja:<p>これですべてだ。他のことはしなくていい。具体的に言うと、この自作のシリアライズ関数は、文字列を返さずに、<em>Pythonの辞書を返している</em>。自分自身では<abbr>JSON</abbr>への完全なシリアライズを行っていない。やっているのはサポートされているデータ型に変換する部分だけだ。残りの仕事は<code>json.dump()</code>関数がやってくれる。


en:<li>The <code>customserializer</code> module is where you just defined the <code>to_json()</code> function in the previous example.
ja:<li><code>customserializer</code>モジュールは、前節で<code>to_json()</code>関数を定義したファイルだ。


en:<li>Text mode, <abbr>UTF-8</abbr> encoding, yadda yadda. (You&#8217;ll forget! I forget sometimes! And everything will work right up until the moment that it fails, and then it will fail most spectacularly.)
ja:<li>テキストモード、<abbr>UTF-8</abbr>エンコーディング、とかなんとかを指定する（きっと忘れるぞ！ 私もときどき忘れてしまう！ しかも、動かなくなるその瞬間までは正しく動いてしまうのだが、時が来ると、本当に壮大に動かなくなる）。


en:<li>This is the important bit: to hook your custom conversion function into the <code>json.dump()</code> function, pass your function into the <code>json.dump()</code> function in the <var>default</var> parameter. (Hooray, <a href=your-first-python-program.html#everythingisanobject>everything in Python is an object</a>!)
ja:<li>これは重要な点だ: 自作の変換用関数を<code>json.dump()</code>関数にフックするために、その関数を<code>json.dump()</code>関数の<var>default</var>パラメータで渡している（やったね、<a href=your-first-python-program.html#everythingisanobject>Pythonではあらゆるものがオブジェクト</a>だ！）。


en:<li>OK, so it didn&#8217;t actually work. But take a look at the exception. The <code>json.dump()</code> function is no longer complaining about being unable to serialize the <code>bytes</code> object. Now it&#8217;s complaining about a completely different object: the <code>time.struct_time</code> object.
ja:<li>OK、これでもまだ動かないようだ。でも例外を見てみよう。もはや<code>json.dump()</code>関数は、<code>bytes</code>オブジェクトをシリアライズできない、という文句を言っていない。今度は、違うオブジェクトについて文句を言っている。<code>time.struct_time</code>オブジェクトだ。


en:<p>While getting a different exception might not seem like progress, it really is! It&#8217;ll just take one more tweak to get past this.
ja:<p>別の例外が発生したので、前進したようには見えないかもしれないが、ちゃんと解決には近づいている！ あともう一手間加えれば、この問題を乗り越えることができる。


en:<li>Adding to our existing <code>customserializer.to_json()</code> function, we need to check whether the Python object (that the <code>json.dump()</code> function is having trouble with) is a <code>time.struct_time</code>.
ja:<li>先ほどの<code>customserializer.to_json()</code>関数にコードを加え、（<code>json.dump()</code>関数が扱いに困っている）Pythonオブジェクトが<code>time.struct_time</code>であるかどうかをチェックする必要がある。


en:<li>If so, we&#8217;ll do something similar to the conversion we did with the <code>bytes</code> object: convert the <code>time.struct_time</code> object to a dictionary that only contains <abbr>JSON</abbr>-serializable values. In this case, the easiest way to convert a datetime into a <abbr>JSON</abbr>-serializable value is to convert it to a string with the <code>time.asctime()</code> function. The <code>time.asctime()</code> function will convert that nasty-looking <code>time.struct_time</code> into the string <code>'Fri Mar 27 22:20:42 2009'</code>.
ja:<li>もしそうであれば、<code>bytes</code>オブジェクトに対して行った変換と似たようなことを行う: <code>time.struct_time</code>オブジェクトを、<abbr>JSON</abbr>がシリアライズできる値だけで構成された辞書に変換するのだ。この場合、日時を<abbr>JSON</abbr>がシリアライズできる値に最も簡単に変換するには、<code>time.asctime()</code>関数を使って文字列に変換すると良いだろう。<code>time.asctime()</code>関数は、見た目の悪い<code>time.struct_time</code>を<code>'Fri Mar 27 22:20:42 2009'</code>という文字列に変換する。


en:<p>With these two custom conversions, the entire <var>entry</var> data structure should serialize to <abbr>JSON</abbr> without any further problems.
ja:<p>これら2つのカスタムな変換をすれば、これ以上の問題を起こすことなく<var>entry</var>データ構造の全体が<abbr>JSON</abbr>にシリアライズされるはずだ。


en:<h2 id=json-load>Loading Data from a <abbr>JSON</abbr> File</h2>
ja:<h2 id=json-load><abbr>JSON</abbr>ファイルからデータを読み込む</h2>


en:<p>Like the <code>pickle</code> module, the <code>json</code> module has a <code>load()</code> function which takes a stream object, reads <abbr>JSON</abbr>-encoded data from it, and creates a new Python object that mirrors the <abbr>JSON</abbr> data structure.
ja:<p><code>json</code>モジュールは、<code>pickle</code>モジュールのように<code>load()</code>関数を持っている。この関数は、ストリームオブジェクトを受け取り、そのオブジェクトから<abbr>JSON</abbr>でエンコードされたデータを読み込み、<abbr>JSON</abbr>のデータ構造を写しとった新しいPythonのオブジェクトを作成する。


en:<li>For demonstration purposes, switch to Python Shell #2 and delete the <var>entry</var> data structure that you created earlier in this chapter with the <code>pickle</code> module.
ja:<li>デモンストレーションを行うために、Pythonシェル #2 に切り替えて、この章の初めの方で<code>pickle</code>モジュールを使って定義した <var>entry</var> データ構造を削除する。


en:<li>In the simplest case, the <code>json.load()</code> function works the same as the <code>pickle.load()</code> function. You pass in a stream object and it returns a new Python object.
ja:<li>この簡単な場合には、<code>json.load()</code>関数は<code>pickle.load()</code>関数と同様にうまく機能する。この関数は、オブジェクトを渡すと新しいPythonオブジェクトを返す。


en:<li>I have good news and bad news. Good news first: the <code>json.load()</code> function successfully read the <code>entry.json</code> file you created in Python Shell #1 and created a new Python object that contained the data. Now the bad news: it didn&#8217;t recreate the original <var>entry</var> data structure. The two values <code>'internal_id'</code> and <code>'published_date'</code> were recreated as dictionaries&nbsp;&mdash;&nbsp;specifically, the dictionaries with <abbr>JSON</abbr>-compatible values that you created in the <code>to_json()</code> conversion function.
ja:<li>良い知らせと悪い知らせがある。まずは良い知らせ: <code>json.load()</code>関数は、Pythonシェル #1 で作成した<code>entry.json</code>を正常に読み込んで、そのデータを格納する新しいPythonオブジェクトを作る。次に悪い知らせ: この関数は <var>entry</var> データ構造を再構成しない。２つの値<code>'internal_id'</code>と<code>'published_date'</code>は辞書だ。具体的に言うと、これらは、変換関数<code>to_json()</code>で作った<abbr>JSON</abbr>互換の値を持った辞書になっている。


en:<p><code>json.load()</code> doesn&#8217;t know anything about any conversion function you may have passed to <code>json.dump()</code>. What you need is the opposite of the <code>to_json()</code> function&nbsp;&mdash;&nbsp;a function that will take a custom-converted <abbr>JSON</abbr> object and convert it back to the original Python datatype.
ja:<p><code>json.load()</code>は、先に<code>json.dump()</code>関数に渡された変換関数については何も知らない。ここで必要なのは<code>to_json()</code>関数とは反対のことをする関数だ。つまり、カスタムな変換を施された<abbr>JSON</abbr>オブジェクトを受け取って、それを元のPythonのデータ型に変換する関数だ。


en:<li>This conversion function also takes one parameter and returns one value. But the parameter it takes is not a string, it&#8217;s a Python object&nbsp;&mdash;&nbsp;the result of deserializing a <abbr>JSON</abbr>-encoded string into Python.
ja:<li>この変換関数も1つのパラメータを受け取って１つの値を返す。しかし、受け取るパラメータは文字列ではなく、<abbr>JSON</abbr>でエンコードされた文字列をデシリアライズすることで得られたPythonオブジェクトだ。


en:<li>All you need to do is check whether this object contains the <code>'__class__'</code> key that the <code>to_json()</code> function created. If so, the value of the <code>'__class__'</code> key will tell you how to decode the value back into the original Python datatype.
ja:<li>やらなければならないことは、このオブジェクトが<code>to_json()</code>によって作られた<code>'__class__'</code>キーを持っているかどうかをチェックすることだけだ。もし、オブジェクトがこのキーを持っているのであれば、元のPythonのデータ型に値をデコードする方法を<code>'__class__'</code>キーが教えてくれる。


en:<li>To decode the time string returned by the <code>time.asctime()</code> function, you use the <code>time.strptime()</code> function. This function takes a formatted datetime string (in a customizable format, but it defaults to the same format that <code>time.asctime()</code> defaults to) and returns a <code>time.struct_time</code>.
ja:<li><code>time.asctime()</code>関数によって返された文字列をデコードするには、<code>time.strptime()</code>関数を使えばよい。この関数はフォーマットされた日時を表す文字列を受け取り（形式はカスタマイズできるが、標準では<code>time.asctime()</code>がデフォルトで返す文字列と同じ形式をとる）<code>time.struct_time</code>を返す。


en:<li>To convert a list of integers back into a <code>bytes</code> object, you can use the <code>bytes()</code> function.
ja:<li>整数のリストを<code>bytes</code>オブジェクトに変換するには、<code>bytes()</code>関数を使うことができる。


en:<p>That was it; there were only two datatypes handled in the <code>to_json()</code> function, and now those two datatypes are handled in the <code>from_json()</code> function. This is the result:
ja:<p>これだけだ。<code>to_json()</code>関数で特別に処理したデータ型は２つだけで、これら２つのデータ型は<code>from_json()</code>関数でも処理されるようになった。以下がその結果だ：


en:<li>To hook the <code>from_json()</code> function into the deserialization process, pass it as the <var>object_hook</var> parameter to the <code>json.load()</code> function. Functions that take functions; it&#8217;s so handy!
ja:<li>デシリアライズの処理の中に<code>from_json()</code>関数をフックするために、この関数を<var>object_hook</var>パラメータとして<code>json.load()</code>関数に渡す。関数を受け取る関数というのはとても便利だね！


en:<li>The <var>entry</var> data structure now contains an <code>'internal_id'</code> key whose value is a <code>bytes</code> object. It also contains a <code>'published_date'</code> key whose value is a <code>time.struct_time</code> object.
ja:<li><var>entry</var>データ構造はキー<code>'internal_id'</code>を持ち、その値は<code>bytes</code>オブジェクトだ。キー<code>'published_date'</code>も持っており、その値は<code>time.struct_time</code>オブジェクトだ。


en:<p>There is one final glitch, though.
ja:<p>しかし、問題があと1つ存在する。


en:<li>Even after hooking the <code>to_json()</code> function into the serialization, and hooking the <code>from_json()</code> function into the deserialization, we still haven&#8217;t recreated a perfect replica of the original data structure. Why not?
ja:<li>シリアライズの処理に<code>to_json()</code>関数をフックし、デシリアライズ処理に<code>from_json()</code>関数をフックし終えたにもかかわらず、私たちは元のデータの完全な複製を再構成することができない。なぜだろう？


en:<li>In the original <var>entry</var> data structure, the value of the <code>'tags'</code> key was a tuple of three strings.
ja:<li>元の<var>entry</var>データ構造では、<code>'tags'</code>キーの値は３つの文字列からなるタプルだった。


en:<li>But in the round-tripped <var>entry2</var> data structure, the value of the <code>'tags'</code> key is a <em>list</em> of three strings. <abbr>JSON</abbr> doesn&#8217;t distinguish between tuples and lists; it only has a single list-like datatype, the array, and the <code>json</code> module silently converts both tuples and lists into <abbr>JSON</abbr> arrays during serialization. For most uses, you can ignore the difference between tuples and lists, but it&#8217;s something to keep in mind as you work with the <code>json</code> module.
ja:<li>しかし、<abbr>JSON</abbr>ファイルから復元した<var>entry2</var>データ構造では、<code>'tags'</code>キーの値は３つの文字列からなる<em>リスト</em>になっている。<abbr>JSON</abbr>はタプルとリストを区別することができない。<abbr>JSON</abbr>にはリストに似たデータ型である配列しか存在しないので、<code>json</code>モジュールはシリアライズの過程でタプルとリストの両方を黙って<abbr>JSON</abbr>の配列に変換する。ほとんどの場合、タプルとリストの違いは無視することができるが、<code>json</code>モジュールを使うときには、このことを心に留めておいたほうが良い。


en:<p><span class=u>&#x261E;</span>Many articles about the <code>pickle</code> module make references to <code>cPickle</code>. In Python 2, there were two implementations of the <code>pickle</code> module, one written in pure Python and another written in C (but still callable from Python). In Python 3, <a href=porting-code-to-python-3-with-2to3.html#othermodules>these two modules have been consolidated</a>, so you should always just <code>import pickle</code>. You may find these articles useful, but you should ignore the now-obsolete information about <code>cPickle</code>.
ja:<p><span class=u>&#x261E;</span><code>pickle</code>モジュールに関する多くの記事は<code>cPickle</code>について言及している。Python 2には<code>pickle</code>モジュールの実装が2つあった。1つは純粋にPythonだけで書かれたもので、もう片方はC言語で書かれたものだ（でもPythonから呼び出せる）。Python 3では、<a href=porting-code-to-python-3-with-2to3.html#othermodules>これらの２つのモジュールは統合された</a>ので、常に<code>import pickle</code>としてインポートしなければならない。これらの記事が役に立つこともあるだろうけれど、<code>cPickle</code>についての時代遅れな情報は無視しよう。


en:<p>On pickling with the <code>pickle</code> module:
ja:<p><code>pickle</code>モジュールを使ったPickle化について：


en:<li><a href=http://docs.python.org/3.1/library/pickle.html><code>pickle</code> module</a>
ja:<li><a href=http://docs.python.org/3.1/library/pickle.html><code>pickle</code>module</a>


en:<li><a href=http://www.doughellmann.com/PyMOTW/pickle/><code>pickle</code> and <code>cPickle</code>&nbsp;&mdash;&nbsp;Python object serialization</a>
ja:<li><a href=http://www.doughellmann.com/PyMOTW/pickle/><code>pickle</code>and<code>cPickle</code>&nbsp;&mdash;&nbsp;Python object serialization</a>


en:<li><a href=http://wiki.python.org/moin/UsingPickle>Using <code>pickle</code></a>
ja:<li><a href=http://wiki.python.org/moin/UsingPickle>Using<code>pickle</code></a>


en:<li><a href=http://www.ibm.com/developerworks/library/l-pypers.html>Python persistence management</a>
ja:<li><a href=http://www.ibm.com/developerworks/library/l-pypers.html>Python persistence management</a>


en:<p>On <abbr>JSON</abbr> and the <code>json</code> module:
ja:<p><abbr>JSON</abbr>と<code>json</code>モジュールについて：


en:<li><a href=http://www.doughellmann.com/PyMOTW/json/><code>json</code>&nbsp;&mdash;&nbsp;JavaScript Object Notation Serializer</a>
ja:<li><a href=http://www.doughellmann.com/PyMOTW/json/><code>json</code>&nbsp;&mdash;&nbsp;JavaScript Object Notation Serializer</a>


en:<li><a href=http://blog.quaternio.net/2009/07/16/json-encoding-and-decoding-with-custom-objects-in-python/>JSON encoding and ecoding with custom objects in Python</a>
ja:<li><a href=http://blog.quaternio.net/2009/07/16/json-encoding-and-decoding-with-custom-objects-in-python/>JSON encoding and ecoding with custom objects in Python</a>


en:<p>On pickle extensibility:
ja:<p>Pickleの拡張性について：


en:<li><a href=http://docs.python.org/3.1/library/pickle.html#pickling-class-instances>Pickling class instances</a>
ja:<li><a href=http://docs.python.org/3.1/library/pickle.html#pickling-class-instances>Pickling class instances</a>


en:<li><a href=http://docs.python.org/3.1/library/pickle.html#persistence-of-external-objects>Persistence of external objects</a>
ja:<li><a href=http://docs.python.org/3.1/library/pickle.html#persistence-of-external-objects>Persistence of external objects</a>


en:<li><a href=http://docs.python.org/3.1/library/pickle.html#handling-stateful-objects>Handling stateful objects</a>
ja:<li><a href=http://docs.python.org/3.1/library/pickle.html#handling-stateful-objects>Handling stateful objects</a>


en:<p class=v><a rel=prev href=xml.html title='back to &#8220;XML&#8221;'><span class=u>&#x261C;</span></a> <a rel=next href=http-web-services.html title='onward to &#8220;HTTP Web Services&#8221;'><span class=u>&#x261E;</span></a>
ja:<p class=v><a rel=prev href=xml.html title='「XML」に戻る'><span class=u>&#x261C;</span></a> <a rel=next href=http-web-services.html title='「HTTP Webサービス」へ進む'><span class=u>&#x261E;</span></a>

